// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Vector {
	float x,y,z;
};

Vector make_vector(float a, float b, float c) {
	Vector v;
	v.x = a;
	v.y = b;
	v.z = c;
	return v;
}

Vector vminus(Vector v1, Vector v2) {
	Vector v3;
	v3.x = v1.x - v2.x;
	v3.y = v1.y - v2.y;
	v3.z = v1.z - v2.z;
	return v3;

}

Vector vmult(float scale, Vector v)
{
  Vector v3;
  v3.x = scale*v.x;
  v3.y = scale*v.y;
  v3.z = scale*v.z;
  return v3;
}

struct Point {
	float x, y, z;  

};

Point make_point(float a, float b, float c) {
	Point p;
    p.x=a;            
    p.y=b;
    p.z=c;
	return p;            
}

Vector pminus(Point p1, Point p2)
{
	Vector v3;
	v3.x = p1.x - p2.x;
	v3.y = p1.y - p2.y;
	v3.z = p1.z - p2.z;
	return v3;
}

Point vpplus(Point p, Vector v)
{
  Point p2;
  p2.x = p.x + v.x;
  p2.y = p.y + v.y;
  p2.z = p.z + v.z;
  return p2;
}

Point pplus(Point p, Point p2)
{
  Point p3;
  p3.x = p.x + p2.x;
  p3.y = p.y + p2.y;
  p3.z = p.z + p2.z;
  return p3;
}

Point spmult(float scale, Point p)
{
  Point p2;
  p2.x = scale*p.x;
  p2.y = scale*p.y;
  p2.z = scale*p.z;
  return p2;
}

struct Sphere {
  Point c; // Sphere center
  float r; // Sphere radius
};

float DotV(Vector v1, Vector v2)
{
  return (v1.x*v2.x + v1.y*v2.y + v1.z*v2.z);
}

float DotP(Point p1, Vector v2)
{
  return (p1.x*v2.x + p1.y*v2.y + p1.z*v2.z);
}

Vector Cross(Vector v1, Vector v2)
{
  Vector v3;       
  v3.x = v1.y*v2.z - v2.y*v1.z;
  v3.y = v1.z*v2.x - v1.x*v2.z;
  v3.z = v1.x*v2.y - v1.y*v2.x;
  return v3;
}

float getmin(const RWStructuredBuffer<Point> points, Vector axis, int length)
{
  float min;

  for (int ctr = 0; ctr < length; ctr++)
    {
      float dotprod = DotP(points[ctr], axis);
      if (dotprod < min || ctr == 0) min = dotprod;
    }
  return min;
}

float getmax(const RWStructuredBuffer<Point> points, Vector axis, int length)
{
  float max;

  for (int ctr = 0; ctr < length; ctr++)
    {
      float dotprod = DotP(points[ctr], axis);
      if (dotprod > max||ctr == 0) max = dotprod;
    }
  return max;
}

bool isect(const RWStructuredBuffer<Point> points1, int length1, const RWStructuredBuffer<Point> points2, int length2, Vector axis)
{
  if (getmin(points1, axis, length1) > getmax(points2, axis, length2)) return false;
  if (getmax(points1, axis, length1) < getmin(points2, axis, length2)) return false;
  return true;     
}

bool isectboxtri(float center[3], float r[3], float3x3 triverts)
{
  RWStructuredBuffer<Point> boxpoints;
  boxpoints[0] = (make_point(center[0]+r[0], center[1]+r[1], center[2]+r[2]));
  boxpoints[1] = (make_point(center[0]+r[0], center[1]+r[1], center[2]-r[2]));
  boxpoints[2] = (make_point(center[0]+r[0], center[1]-r[1], center[2]+r[2]));
  boxpoints[3] = (make_point(center[0]+r[0], center[1]-r[1], center[2]-r[2]));
  boxpoints[4] = (make_point(center[0]-r[0], center[1]+r[1], center[2]+r[2]));
  boxpoints[5] = (make_point(center[0]-r[0], center[1]+r[1], center[2]-r[2]));
  boxpoints[6] = (make_point(center[0]-r[0], center[1]-r[1], center[2]+r[2]));
  boxpoints[7] = (make_point(center[0]-r[0], center[1]-r[1], center[2]-r[2]));
 
  RWStructuredBuffer<Point> tripoints;
  tripoints[0] = (make_point(triverts[0][0], triverts[0][1], triverts[0][2]));
  tripoints[1] = (make_point(triverts[1][0], triverts[1][1], triverts[1][2]));
  tripoints[2] = (make_point(triverts[2][0], triverts[2][1], triverts[2][2]));

  // test the x, y, and z axes
  if (!isect(boxpoints, 8, tripoints, 3, make_vector(1, 0, 0))) return false;
  if (!isect(boxpoints, 8, tripoints, 3, make_vector(0, 1, 0))) return false;
  if (!isect(boxpoints, 8, tripoints, 3, make_vector(0, 0, 1))) return false;

  // test the triangle normal
  Vector triedge1 = pminus(tripoints[1], tripoints[0]);
  Vector triedge2 = pminus(tripoints[2], tripoints[1]);
  Vector trinormal = Cross(triedge1, triedge2);
  if (!isect(boxpoints, 8, tripoints, 3, trinormal)) return false;

  // test the 9 edge cross products
  Vector triedge3 = pminus(tripoints[0], tripoints[2]);

  Vector boxedge1 = make_vector(1, 0, 0);
  Vector boxedge2 = make_vector(0, 1, 0);
  Vector boxedge3 = make_vector(0, 0, 1);

  if (!isect(boxpoints, 8, tripoints, 3, Cross(boxedge1, triedge1))) return false;
  if (!isect(boxpoints, 8, tripoints, 3, Cross(boxedge1, triedge2))) return false;
  if (!isect(boxpoints, 8, tripoints, 3, Cross(boxedge1, triedge3))) return false;

  if (!isect(boxpoints, 8, tripoints, 3, Cross(boxedge2, triedge1))) return false;
  if (!isect(boxpoints, 8, tripoints, 3, Cross(boxedge2, triedge2))) return false;
  if (!isect(boxpoints, 8, tripoints, 3, Cross(boxedge2, triedge3))) return false;

  if (!isect(boxpoints, 8, tripoints, 3, Cross(boxedge3, triedge1))) return false;
  if (!isect(boxpoints, 8, tripoints, 3, Cross(boxedge3, triedge2))) return false;
  if (!isect(boxpoints, 8, tripoints, 3, Cross(boxedge3, triedge3))) return false;

  return true;
     
}

float GetTriangleNormalZ(float3x3 triverts) {

	float first = (triverts[1][0]-triverts[0][0])*(triverts[2][1]-triverts[0][1]);
	float second = (triverts[1][1]-triverts[0][1])*(triverts[2][0]-triverts[0][0]);

	return first - second;
}

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<int> Result;
RWStructuredBuffer<float3x3> triangles;
bool storeNormalSum;
float3 origin;
float side;
float ignoreNormalRange;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	int index = 1;

	float3x3 triverts = triangles[index];

	float vert1;
	float vert2;
	float vert3;
	float firstMin;
	float firstMax;

	vert1 = triverts[0][0];
	vert2 = triverts[1][0];
	vert3 = triverts[2][0];
	firstMin = min(vert2, vert3);
	int startX = floor((min(vert1, firstMin) - origin[0]) / side);
	firstMax = max(vert2, vert3);
	int endX = ceil((max(vert1, firstMax) - origin[0]) / side);

	vert1 = triverts[0][1];
	vert2 = triverts[1][1];
	vert3 = triverts[2][1];
	firstMin = min(vert2, vert3);
	int startY = floor((min(vert1, firstMin) - origin[1]) / side);
	firstMax = max(vert2, vert3);
	int endY = ceil((max(vert1, firstMax) - origin[1]) / side);

	vert1 = triverts[0][2];
	vert2 = triverts[1][2];
	vert3 = triverts[2][2];
	firstMin = min(vert2, vert3);
	int startZ = floor((min(vert1, firstMin) - origin[2]) / side);
	firstMax = max(vert2, vert3);
	int endZ = ceil((max(vert1, firstMax) - origin[2]) / side);

	float center[3] = {1,1,1};
	float r[3] = {side,side,side};
	if (isectboxtri(center, r, triverts)) {
	}

	if (storeNormalSum) {
		for (int x = 0; x <= 10; ++x) {
			for (int y = 0; y <= 10; ++y) {
				for (int z = 0; z <= 10; ++z) {
					float center[3] = {x,y,z};
					float r[3] = {side,side,side};
					if (isectboxtri(center, r, triverts)) {
						float triangleNormalZ = GetTriangleNormalZ(triverts);
						//cubeSet[x, y, z] = true;
						if (triangleNormalZ < 0 - ignoreNormalRange) {
							//cubeNormalSum[x, y, z]++;
						} else if (triangleNormalZ > 0 + ignoreNormalRange){
							//cubeNormalSum[x, y, z]--;
						}
					}
				}
			}
		}
	} else {
		for (int x = 0; x < 10; ++x) {
			for (int y = 0; y < 10; ++y) {
				for (int z = 0; z < 10; ++z) {
					float center[3] = {x,y,z};
					float r[3] = {side,side,side};
					if (/*!IsAABCSet(x, y, z) && */isectboxtri(center, r, triverts)) {
						//Result[x, y, z] = 1;
					}
				}
			}
		}
	}


}
